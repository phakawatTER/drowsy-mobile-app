{"ast":null,"code":"var _jsxFileName = \"/Users/phakawat/Desktop/drowsy-mobile-app/node_modules/react-native-svg-charts/src/stacked-bar-chart/stacked-bar-chart.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport * as array from 'd3-array';\nimport * as scale from 'd3-scale';\nimport * as shape from 'd3-shape';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport Svg from 'react-native-svg';\nimport Path from \"../animated-path\";\n\nclass BarChart extends PureComponent {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      width: 0,\n      height: 0\n    };\n  }\n\n  static extractDataPoints(data, keys) {\n    var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : shape.stackOrderNone;\n    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : shape.stackOffsetNone;\n    var series = shape.stack().keys(keys).order(order).offset(offset)(data);\n    return array.merge(array.merge(series));\n  }\n\n  _onLayout(event) {\n    var {\n      nativeEvent: {\n        layout: {\n          height,\n          width\n        }\n      }\n    } = event;\n    this.setState({\n      height,\n      width\n    });\n  }\n\n  calcXScale(domain) {\n    var {\n      data\n    } = this.props;\n    var {\n      horizontal,\n      contentInset: {\n        left = 0,\n        right = 0\n      },\n      spacingInner,\n      spacingOuter\n    } = this.props;\n    var {\n      width\n    } = this.state;\n\n    if (horizontal) {\n      return scale.scaleLinear().domain(domain).range([left, width - right]);\n    }\n\n    return scale.scaleBand().domain(data.map((_, index) => index)).range([left, width - right]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n  }\n\n  calcYScale(domain) {\n    var {\n      data\n    } = this.props;\n    var {\n      horizontal,\n      contentInset: {\n        top = 0,\n        bottom = 0\n      },\n      spacingInner,\n      spacingOuter\n    } = this.props;\n    var {\n      height\n    } = this.state;\n\n    if (horizontal) {\n      return scale.scaleBand().domain(data.map((_, index) => index)).range([top, height - bottom]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n    }\n\n    return scale.scaleLinear().domain(domain).range([height - bottom, top]);\n  }\n\n  calcAreas(x, y, series) {\n    var {\n      horizontal,\n      colors,\n      keys\n    } = this.props;\n\n    if (horizontal) {\n      return array.merge(series.map((serie, keyIndex) => {\n        return serie.map((entry, entryIndex) => {\n          var path = shape.area().x0(d => x(d[0])).x1(d => x(d[1])).y((d, _index) => _index === 0 ? y(entryIndex) : y(entryIndex) + y.bandwidth()).defined(d => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry]);\n          return {\n            path,\n            color: colors[keyIndex],\n            key: keys[keyIndex]\n          };\n        });\n      }));\n    }\n\n    return array.merge(series.map((serie, keyIndex) => {\n      return serie.map((entry, entryIndex) => {\n        var path = shape.area().y0(d => y(d[0])).y1(d => y(d[1])).x((d, _index) => _index === 0 ? x(entryIndex) : x(entryIndex) + x.bandwidth()).defined(d => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry]);\n        return {\n          path,\n          color: colors[keyIndex],\n          key: keys[keyIndex]\n        };\n      });\n    }));\n  }\n\n  calcExtent(values) {\n    var {\n      gridMax,\n      gridMin\n    } = this.props;\n    return array.extent([...values, gridMin, gridMax]);\n  }\n\n  calcIndexes(values) {\n    return values.map((_, index) => index);\n  }\n\n  getSeries() {\n    var {\n      data,\n      keys,\n      offset,\n      order,\n      valueAccessor\n    } = this.props;\n    return shape.stack().keys(keys).value((item, key) => valueAccessor({\n      item,\n      key\n    })).order(order).offset(offset)(data);\n  }\n\n  render() {\n    var {\n      data,\n      animate,\n      animationDuration,\n      style,\n      numberOfTicks,\n      children,\n      horizontal\n    } = this.props;\n    var {\n      height,\n      width\n    } = this.state;\n\n    if (data.length === 0) {\n      return React.createElement(View, {\n        style: style,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 164\n        }\n      });\n    }\n\n    var series = this.getSeries();\n    var values = array.merge(array.merge(series));\n    var indexes = this.calcIndexes(values);\n    var extent = this.calcExtent(values);\n    var ticks = array.ticks(extent[0], extent[1], numberOfTicks);\n    var xDomain = horizontal ? extent : indexes;\n    var yDomain = horizontal ? indexes : extent;\n    var x = this.calcXScale(xDomain);\n    var y = this.calcYScale(yDomain);\n    var bandwidth = horizontal ? y.bandwidth() : x.bandwidth();\n    var areas = this.calcAreas(x, y, series);\n    var extraProps = {\n      x,\n      y,\n      width,\n      height,\n      ticks,\n      data,\n      bandwidth\n    };\n    return React.createElement(View, {\n      style: style,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 197\n      }\n    }, React.createElement(View, {\n      style: {\n        flex: 1\n      },\n      onLayout: event => this._onLayout(event),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 198\n      }\n    }, height > 0 && width > 0 && React.createElement(Svg, {\n      style: {\n        height,\n        width\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 200\n      }\n    }, React.Children.map(children, child => {\n      if (child && child.props.belowChart) {\n        return React.cloneElement(child, extraProps);\n      }\n\n      return null;\n    }), areas.map((bar, index) => {\n      var keyIndex = index % data.length;\n      var key = \"\".concat(keyIndex, \"-\").concat(bar.key);\n      var {\n        svg\n      } = data[keyIndex][bar.key];\n      return React.createElement(Path, _extends({\n        key: key,\n        fill: bar.color\n      }, svg, {\n        d: bar.path,\n        animate: animate,\n        animationDuration: animationDuration,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 213\n        }\n      }));\n    }), React.Children.map(children, child => {\n      if (child && !child.props.belowChart) {\n        return React.cloneElement(child, extraProps);\n      }\n\n      return null;\n    }))));\n  }\n\n}\n\nBarChart.propTypes = {\n  data: PropTypes.arrayOf(PropTypes.object),\n  keys: PropTypes.arrayOf(PropTypes.string).isRequired,\n  colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n  offset: PropTypes.func,\n  order: PropTypes.func,\n  style: PropTypes.any,\n  spacingInner: PropTypes.number,\n  spacingOuter: PropTypes.number,\n  animate: PropTypes.bool,\n  animationDuration: PropTypes.number,\n  contentInset: PropTypes.shape({\n    top: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    bottom: PropTypes.number\n  }),\n  gridMin: PropTypes.number,\n  gridMax: PropTypes.number,\n  valueAccessor: PropTypes.func\n};\nBarChart.defaultProps = {\n  spacingInner: 0.05,\n  spacingOuter: 0.05,\n  offset: shape.stackOffsetNone,\n  order: shape.stackOrderNone,\n  width: 100,\n  height: 100,\n  showZeroAxis: true,\n  contentInset: {},\n  numberOfTicks: 10,\n  showGrid: true,\n  valueAccessor: (_ref) => {\n    var {\n      item,\n      key\n    } = _ref;\n    return item[key];\n  }\n};\nexport default BarChart;","map":{"version":3,"sources":["/Users/phakawat/Desktop/drowsy-mobile-app/node_modules/react-native-svg-charts/src/stacked-bar-chart/stacked-bar-chart.js"],"names":["array","scale","shape","PropTypes","React","PureComponent","Svg","Path","BarChart","state","width","height","extractDataPoints","data","keys","order","stackOrderNone","offset","stackOffsetNone","series","stack","merge","_onLayout","event","nativeEvent","layout","setState","calcXScale","domain","props","horizontal","contentInset","left","right","spacingInner","spacingOuter","scaleLinear","range","scaleBand","map","_","index","paddingInner","paddingOuter","calcYScale","top","bottom","calcAreas","x","y","colors","serie","keyIndex","entry","entryIndex","path","area","x0","d","x1","_index","bandwidth","defined","isNaN","color","key","y0","y1","calcExtent","values","gridMax","gridMin","extent","calcIndexes","getSeries","valueAccessor","value","item","render","animate","animationDuration","style","numberOfTicks","children","length","indexes","ticks","xDomain","yDomain","areas","extraProps","flex","Children","child","belowChart","cloneElement","bar","svg","propTypes","arrayOf","object","string","isRequired","func","any","number","bool","defaultProps","showZeroAxis","showGrid"],"mappings":"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","sourcesContent":["import * as array from 'd3-array'\nimport * as scale from 'd3-scale'\nimport * as shape from 'd3-shape'\nimport PropTypes from 'prop-types'\nimport React, { PureComponent } from 'react'\nimport { View } from 'react-native'\nimport Svg from 'react-native-svg'\nimport Path from '../animated-path'\n\nclass BarChart extends PureComponent {\n    static extractDataPoints(data, keys, order = shape.stackOrderNone, offset = shape.stackOffsetNone) {\n        const series = shape\n            .stack()\n            .keys(keys)\n            .order(order)\n            .offset(offset)(data)\n\n        //double merge arrays to extract just the values\n        return array.merge(array.merge(series))\n    }\n\n    state = {\n        width: 0,\n        height: 0,\n    }\n\n    _onLayout(event) {\n        const {\n            nativeEvent: {\n                layout: { height, width },\n            },\n        } = event\n        this.setState({ height, width })\n    }\n\n    calcXScale(domain) {\n        const { data } = this.props\n\n        const {\n            horizontal,\n            contentInset: { left = 0, right = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { width } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleLinear()\n                .domain(domain)\n                .range([left, width - right])\n        }\n\n        // use index as domain identifier instead of value since\n        // domain must be same length as number of bars\n        // same value can occur at several places in data\n        return scale\n            .scaleBand()\n            .domain(data.map((_, index) => index))\n            .range([left, width - right])\n            .paddingInner([spacingInner])\n            .paddingOuter([spacingOuter])\n    }\n\n    calcYScale(domain) {\n        const { data } = this.props\n\n        const {\n            horizontal,\n            contentInset: { top = 0, bottom = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { height } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleBand()\n                .domain(data.map((_, index) => index))\n                .range([top, height - bottom])\n                .paddingInner([spacingInner])\n                .paddingOuter([spacingOuter])\n        }\n\n        return scale\n            .scaleLinear()\n            .domain(domain)\n            .range([height - bottom, top])\n    }\n\n    calcAreas(x, y, series) {\n        const { horizontal, colors, keys } = this.props\n\n        if (horizontal) {\n            return array.merge(\n                series.map((serie, keyIndex) => {\n                    return serie.map((entry, entryIndex) => {\n                        const path = shape\n                            .area()\n                            .x0((d) => x(d[0]))\n                            .x1((d) => x(d[1]))\n                            .y((d, _index) => (_index === 0 ? y(entryIndex) : y(entryIndex) + y.bandwidth()))\n                            .defined((d) => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry])\n\n                        return {\n                            path,\n                            color: colors[keyIndex],\n                            key: keys[keyIndex],\n                        }\n                    })\n                })\n            )\n        }\n\n        return array.merge(\n            series.map((serie, keyIndex) => {\n                return serie.map((entry, entryIndex) => {\n                    const path = shape\n                        .area()\n                        .y0((d) => y(d[0]))\n                        .y1((d) => y(d[1]))\n                        .x((d, _index) => (_index === 0 ? x(entryIndex) : x(entryIndex) + x.bandwidth()))\n                        .defined((d) => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry])\n\n                    return {\n                        path,\n                        color: colors[keyIndex],\n                        key: keys[keyIndex],\n                    }\n                })\n            })\n        )\n    }\n\n    calcExtent(values) {\n        const { gridMax, gridMin } = this.props\n\n        return array.extent([...values, gridMin, gridMax])\n    }\n\n    calcIndexes(values) {\n        return values.map((_, index) => index)\n    }\n\n    getSeries() {\n        const { data, keys, offset, order, valueAccessor } = this.props\n\n        return shape\n            .stack()\n            .keys(keys)\n            .value((item, key) => valueAccessor({ item, key }))\n            .order(order)\n            .offset(offset)(data)\n    }\n\n    render() {\n        const { data, animate, animationDuration, style, numberOfTicks, children, horizontal } = this.props\n\n        const { height, width } = this.state\n\n        if (data.length === 0) {\n            return <View style={style} />\n        }\n\n        const series = this.getSeries()\n\n        //double merge arrays to extract just the values\n        const values = array.merge(array.merge(series))\n        const indexes = this.calcIndexes(values)\n\n        const extent = this.calcExtent(values)\n        const ticks = array.ticks(extent[0], extent[1], numberOfTicks)\n\n        const xDomain = horizontal ? extent : indexes\n        const yDomain = horizontal ? indexes : extent\n\n        const x = this.calcXScale(xDomain)\n        const y = this.calcYScale(yDomain)\n\n        const bandwidth = horizontal ? y.bandwidth() : x.bandwidth()\n\n        const areas = this.calcAreas(x, y, series)\n\n        const extraProps = {\n            x,\n            y,\n            width,\n            height,\n            ticks,\n            data,\n            bandwidth,\n        }\n\n        return (\n            <View style={style}>\n                <View style={{ flex: 1 }} onLayout={(event) => this._onLayout(event)}>\n                    {height > 0 && width > 0 && (\n                        <Svg style={{ height, width }}>\n                            {React.Children.map(children, (child) => {\n                                if (child && child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                            {areas.map((bar, index) => {\n                                const keyIndex = index % data.length\n                                const key = `${keyIndex}-${bar.key}`\n                                const { svg } = data[keyIndex][bar.key]\n\n                                return (\n                                    <Path\n                                        key={key}\n                                        fill={bar.color}\n                                        {...svg}\n                                        d={bar.path}\n                                        animate={animate}\n                                        animationDuration={animationDuration}\n                                    />\n                                )\n                            })}\n                            {React.Children.map(children, (child) => {\n                                if (child && !child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                        </Svg>\n                    )}\n                </View>\n            </View>\n        )\n    }\n}\n\nBarChart.propTypes = {\n    data: PropTypes.arrayOf(PropTypes.object),\n    keys: PropTypes.arrayOf(PropTypes.string).isRequired,\n    colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n    offset: PropTypes.func,\n    order: PropTypes.func,\n    style: PropTypes.any,\n    spacingInner: PropTypes.number,\n    spacingOuter: PropTypes.number,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    contentInset: PropTypes.shape({\n        top: PropTypes.number,\n        left: PropTypes.number,\n        right: PropTypes.number,\n        bottom: PropTypes.number,\n    }),\n    gridMin: PropTypes.number,\n    gridMax: PropTypes.number,\n    valueAccessor: PropTypes.func,\n}\n\nBarChart.defaultProps = {\n    spacingInner: 0.05,\n    spacingOuter: 0.05,\n    offset: shape.stackOffsetNone,\n    order: shape.stackOrderNone,\n    width: 100,\n    height: 100,\n    showZeroAxis: true,\n    contentInset: {},\n    numberOfTicks: 10,\n    showGrid: true,\n    valueAccessor: ({ item, key }) => item[key],\n}\n\nexport default BarChart\n"]},"metadata":{},"sourceType":"module"}