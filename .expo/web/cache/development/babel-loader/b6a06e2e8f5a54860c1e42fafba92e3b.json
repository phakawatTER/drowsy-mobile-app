{"ast":null,"code":"var _jsxFileName = \"/Users/phakawat/Desktop/drowsy-mobile-app/node_modules/react-native-svg-charts/src/stacked-bar-chart/stacked-bar-grouped.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { PureComponent } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport PropTypes from 'prop-types';\nimport Svg from 'react-native-svg';\nimport * as array from 'd3-array';\nimport * as scale from 'd3-scale';\nimport * as shape from 'd3-shape';\nimport Path from \"../animated-path\";\n\nclass StackedBarGrouped extends PureComponent {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      width: 0,\n      height: 0\n    };\n\n    this.coordinatesToPathCommands = (x0, y0, x1, y1, borderRadius, showTopBorder, showBottomBorder) => {\n      var commands = [];\n      commands.push({\n        marker: 'M',\n        values: [x0, y0]\n      });\n\n      if (showTopBorder) {\n        var topLeft1 = [x0 + borderRadius, y0];\n        var topLeft2 = [x0, y0 + borderRadius];\n        commands.push({\n          marker: 'L',\n          values: topLeft1\n        });\n        commands.push({\n          marker: 'C',\n          values: [...topLeft1, x0, y0, ...topLeft2]\n        });\n        commands.push({\n          marker: 'L',\n          values: topLeft2\n        });\n      } else {\n        commands.push({\n          marker: 'L',\n          values: [x0, y0]\n        });\n      }\n\n      if (showBottomBorder) {\n        var bottomLeft1 = [x0, y1 - borderRadius];\n        var bottomLeft2 = [x0 + borderRadius, y1];\n        commands.push({\n          marker: 'L',\n          values: bottomLeft1\n        });\n        commands.push({\n          marker: 'C',\n          values: [...bottomLeft1, x0, y1, ...bottomLeft2]\n        });\n        commands.push({\n          marker: 'L',\n          values: bottomLeft2\n        });\n        var bottomRight1 = [x1 - borderRadius, y1];\n        var bottomRight2 = [x1, y1 - borderRadius];\n        commands.push({\n          marker: 'L',\n          values: bottomRight1\n        });\n        commands.push({\n          marker: 'C',\n          values: [...bottomRight1, x1, y1, ...bottomRight2]\n        });\n        commands.push({\n          marker: 'L',\n          values: bottomRight2\n        });\n      } else {\n        commands.push({\n          marker: 'L',\n          values: [x0, y1]\n        });\n        commands.push({\n          marker: 'L',\n          values: [x1, y1]\n        });\n      }\n\n      if (showTopBorder) {\n        var topRight1 = [x1, y0 + borderRadius];\n        var topRight2 = [x1 - borderRadius, y0];\n        commands.push({\n          marker: 'L',\n          values: topRight1\n        });\n        commands.push({\n          marker: 'C',\n          values: [...topRight1, x1, y0, ...topRight2]\n        });\n        commands.push({\n          marker: 'L',\n          values: topRight2\n        });\n      } else {\n        commands.push({\n          marker: 'L',\n          values: [x1, y0]\n        });\n      }\n\n      commands.push({\n        marker: 'Z',\n        values: []\n      });\n      return commands;\n    };\n\n    this.commandsToSvgPath = commands => commands.map(command => \"\".concat(command.marker, \" \").concat(command.values.join(','))).join(' ').trim();\n  }\n\n  _onLayout(event) {\n    var {\n      nativeEvent: {\n        layout: {\n          height,\n          width\n        }\n      }\n    } = event;\n    this.setState({\n      height,\n      width\n    });\n  }\n\n  calcXScale(domain) {\n    var {\n      horizontal,\n      contentInset: {\n        left = 0,\n        right = 0\n      },\n      spacingInner,\n      spacingOuter\n    } = this.props;\n    var {\n      width\n    } = this.state;\n\n    if (horizontal) {\n      return scale.scaleLinear().domain(domain).range([left, width - right]);\n    }\n\n    return scale.scaleBand().domain(domain).range([left, width - right]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n  }\n\n  calcYScale(domain) {\n    var {\n      horizontal,\n      contentInset: {\n        top = 0,\n        bottom = 0\n      },\n      spacingInner,\n      spacingOuter\n    } = this.props;\n    var {\n      height\n    } = this.state;\n\n    if (horizontal) {\n      return scale.scaleBand().domain(domain).range([top, height - bottom]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n    }\n\n    return scale.scaleLinear().domain(domain).range([height - bottom, top]);\n  }\n\n  calcAreas(x, y, series) {\n    var {\n      horizontal,\n      colors,\n      keys,\n      data,\n      borderRadius: initialBorderRadius,\n      innerBarSpace\n    } = this.props;\n    var areas;\n    var barWidth;\n\n    if (horizontal) {\n      barWidth = y.bandwidth() / data.length;\n      areas = series.map((stack, stackIndex) => {\n        return stack.map((serie, keyIndex) => {\n          return serie.map((entry, entryIndex) => {\n            var leftMargin = series.length > 1 ? innerBarSpace / 2 : 0;\n            var path = shape.area().x0(d => x(d[0])).x1(d => x(d[1])).y((d, _index) => (_index === 0 ? y(entryIndex) + barWidth * stackIndex + leftMargin : y(entryIndex) + barWidth + barWidth * stackIndex) - leftMargin).defined(d => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry]);\n            return {\n              path,\n              color: colors[stackIndex][keyIndex],\n              key: keys[stackIndex][keyIndex]\n            };\n          });\n        });\n      });\n    } else {\n      barWidth = x.bandwidth() / data.length;\n      areas = series.map((stack, stackIndex) => {\n        return stack.map((serie, keyIndex) => {\n          return serie.map((entry, entryIndex) => {\n            var leftMargin = series.length > 1 ? innerBarSpace / 2 : 0;\n            var x0 = x(entryIndex) + barWidth * stackIndex + leftMargin;\n            var x1 = x(entryIndex) + barWidth + barWidth * stackIndex - leftMargin;\n            var y0 = y(entry[1]);\n            var y1 = y(entry[0]);\n            var barHeight = y1 - y0;\n            var borderRadius = initialBorderRadius * 2 > barHeight ? barHeight / 2 : initialBorderRadius;\n            var showTopBorder = keyIndex === stack.length - 1;\n            var showBottomBorder = keyIndex === 0;\n            var commands = this.coordinatesToPathCommands(x0, y0, x1, y1, borderRadius, showTopBorder, showBottomBorder);\n            return {\n              path: this.commandsToSvgPath(commands),\n              color: colors[stackIndex][keyIndex],\n              key: keys[stackIndex][keyIndex]\n            };\n          });\n        });\n      });\n    }\n\n    return array.merge(areas);\n  }\n\n  calcExtent(values) {\n    var {\n      gridMax,\n      gridMin\n    } = this.props;\n    var mergedValues = array.merge(values);\n    return array.extent([...mergedValues, gridMin, gridMax]);\n  }\n\n  calcIndexes() {\n    var {\n      data\n    } = this.props;\n    return data[0].data.map((_, index) => index);\n  }\n\n  getSeries() {\n    var {\n      data,\n      keys,\n      offset,\n      order,\n      valueAccessor\n    } = this.props;\n    return data.map((obj, index) => shape.stack().keys(keys[index]).value((item, key) => valueAccessor({\n      item,\n      key\n    })).order(order).offset(offset)(obj.data));\n  }\n\n  render() {\n    var {\n      data,\n      animate,\n      animationDuration,\n      style,\n      numberOfTicks,\n      children,\n      horizontal\n    } = this.props;\n    var {\n      height,\n      width\n    } = this.state;\n\n    if (data.length === 0) {\n      return React.createElement(View, {\n        style: style,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 245\n        }\n      });\n    }\n\n    var series = this.getSeries();\n    var values = array.merge(array.merge(series));\n    var indexes = this.calcIndexes(values);\n    var extent = this.calcExtent(values);\n    var ticks = array.ticks(extent[0], extent[1], numberOfTicks);\n    var xDomain = horizontal ? extent : indexes;\n    var yDomain = horizontal ? indexes : extent;\n    var x = this.calcXScale(xDomain);\n    var y = this.calcYScale(yDomain);\n    var bandwidth = horizontal ? y.bandwidth() : x.bandwidth();\n    var stacks = this.calcAreas(x, y, series);\n    var extraProps = {\n      x,\n      y,\n      width,\n      height,\n      ticks,\n      data,\n      bandwidth\n    };\n    return React.createElement(View, {\n      style: style,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 278\n      }\n    }, React.createElement(View, {\n      style: {\n        flex: 1\n      },\n      onLayout: event => this._onLayout(event),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 279\n      }\n    }, height > 0 && width > 0 && React.createElement(Svg, {\n      style: {\n        height,\n        width\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 281\n      }\n    }, React.Children.map(children, child => {\n      if (child && child.props.belowChart) {\n        return React.cloneElement(child, extraProps);\n      }\n\n      return null;\n    }), stacks.map((areas, indexStack) => {\n      var areaIndex = indexStack % data.length;\n      return areas.map((bar, indexArea) => {\n        var keyIndex = indexArea % data[areaIndex].data.length;\n        var key = \"\".concat(areaIndex, \"-\").concat(keyIndex, \"-\").concat(bar.key);\n        var {\n          svg\n        } = data[areaIndex].data[keyIndex][bar.key];\n        return React.createElement(Path, _extends({\n          key: key,\n          fill: bar.color\n        }, svg, {\n          d: bar.path,\n          animate: animate,\n          animationDuration: animationDuration,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 298\n          }\n        }));\n      });\n    }), React.Children.map(children, child => {\n      if (child && !child.props.belowChart) {\n        return React.cloneElement(child, extraProps);\n      }\n\n      return null;\n    }))));\n  }\n\n}\n\nStackedBarGrouped.propTypes = {\n  data: PropTypes.arrayOf(PropTypes.object),\n  keys: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n  colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n  offset: PropTypes.func,\n  order: PropTypes.func,\n  style: PropTypes.any,\n  spacingInner: PropTypes.number,\n  spacingOuter: PropTypes.number,\n  animate: PropTypes.bool,\n  animationDuration: PropTypes.number,\n  contentInset: PropTypes.shape({\n    top: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    bottom: PropTypes.number\n  }),\n  gridMin: PropTypes.number,\n  gridMax: PropTypes.number,\n  valueAccessor: PropTypes.func,\n  borderRadius: PropTypes.number,\n  innerBarSpace: PropTypes.number\n};\nStackedBarGrouped.defaultProps = {\n  spacingInner: 0.05,\n  spacingOuter: 0.05,\n  offset: shape.stackOffsetNone,\n  order: shape.stackOrderNone,\n  width: 100,\n  height: 100,\n  showZeroAxis: true,\n  contentInset: {},\n  numberOfTicks: 10,\n  showGrid: true,\n  valueAccessor: (_ref) => {\n    var {\n      item,\n      key\n    } = _ref;\n    return item[key];\n  },\n  borderRadius: 0,\n  innerBarSpace: 0\n};\nexport default StackedBarGrouped;","map":{"version":3,"sources":["/Users/phakawat/Desktop/drowsy-mobile-app/node_modules/react-native-svg-charts/src/stacked-bar-chart/stacked-bar-grouped.js"],"names":["React","PureComponent","PropTypes","Svg","array","scale","shape","Path","StackedBarGrouped","state","width","height","coordinatesToPathCommands","x0","y0","x1","y1","borderRadius","showTopBorder","showBottomBorder","commands","push","marker","values","topLeft1","topLeft2","bottomLeft1","bottomLeft2","bottomRight1","bottomRight2","topRight1","topRight2","commandsToSvgPath","map","command","join","trim","_onLayout","event","nativeEvent","layout","setState","calcXScale","domain","horizontal","contentInset","left","right","spacingInner","spacingOuter","props","scaleLinear","range","scaleBand","paddingInner","paddingOuter","calcYScale","top","bottom","calcAreas","x","y","series","colors","keys","data","initialBorderRadius","innerBarSpace","areas","barWidth","bandwidth","length","stack","stackIndex","serie","keyIndex","entry","entryIndex","leftMargin","path","area","d","_index","defined","isNaN","color","key","barHeight","merge","calcExtent","gridMax","gridMin","mergedValues","extent","calcIndexes","_","index","getSeries","offset","order","valueAccessor","obj","value","item","render","animate","animationDuration","style","numberOfTicks","children","indexes","ticks","xDomain","yDomain","stacks","extraProps","flex","Children","child","belowChart","cloneElement","indexStack","areaIndex","bar","indexArea","svg","propTypes","arrayOf","object","string","isRequired","func","any","number","bool","defaultProps","stackOffsetNone","stackOrderNone","showZeroAxis","showGrid"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react'\nimport { View } from 'react-native'\nimport PropTypes from 'prop-types'\nimport Svg from 'react-native-svg'\nimport * as array from 'd3-array'\nimport * as scale from 'd3-scale'\nimport * as shape from 'd3-shape'\nimport Path from '../animated-path'\n\nclass StackedBarGrouped extends PureComponent {\n    state = {\n        width: 0,\n        height: 0,\n    }\n\n    _onLayout(event) {\n        const {\n            nativeEvent: {\n                layout: { height, width },\n            },\n        } = event\n        this.setState({ height, width })\n    }\n\n    calcXScale(domain) {\n        const {\n            horizontal,\n            contentInset: { left = 0, right = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { width } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleLinear()\n                .domain(domain)\n                .range([left, width - right])\n        }\n\n        return scale\n            .scaleBand()\n            .domain(domain)\n            .range([left, width - right])\n            .paddingInner([spacingInner])\n            .paddingOuter([spacingOuter])\n    }\n\n    calcYScale(domain) {\n        const {\n            horizontal,\n            contentInset: { top = 0, bottom = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { height } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleBand()\n                .domain(domain)\n                .range([top, height - bottom])\n                .paddingInner([spacingInner])\n                .paddingOuter([spacingOuter])\n        }\n\n        return scale\n            .scaleLinear()\n            .domain(domain)\n            .range([height - bottom, top])\n    }\n\n    calcAreas(x, y, series) {\n        const { horizontal, colors, keys, data, borderRadius: initialBorderRadius, innerBarSpace } = this.props\n        let areas\n        let barWidth\n\n        if (horizontal) {\n            barWidth = y.bandwidth() / data.length\n\n            areas = series.map((stack, stackIndex) => {\n                return stack.map((serie, keyIndex) => {\n                    return serie.map((entry, entryIndex) => {\n                        const leftMargin = series.length > 1 ? innerBarSpace / 2 : 0\n\n                        const path = shape\n                            .area()\n                            .x0((d) => x(d[0]))\n                            .x1((d) => x(d[1]))\n                            .y(\n                                (d, _index) =>\n                                    (_index === 0\n                                        ? y(entryIndex) + barWidth * stackIndex + leftMargin\n                                        : y(entryIndex) + barWidth + barWidth * stackIndex) - leftMargin\n                            )\n                            .defined((d) => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry])\n\n                        return {\n                            path,\n                            color: colors[stackIndex][keyIndex],\n                            key: keys[stackIndex][keyIndex],\n                        }\n                    })\n                })\n            })\n        } else {\n            barWidth = x.bandwidth() / data.length\n\n            areas = series.map((stack, stackIndex) => {\n                return stack.map((serie, keyIndex) => {\n                    return serie.map((entry, entryIndex) => {\n                        const leftMargin = series.length > 1 ? innerBarSpace / 2 : 0\n                        const x0 = x(entryIndex) + barWidth * stackIndex + leftMargin\n                        const x1 = x(entryIndex) + barWidth + barWidth * stackIndex - leftMargin\n                        const y0 = y(entry[1])\n                        const y1 = y(entry[0])\n                        const barHeight = y1 - y0\n                        const borderRadius = initialBorderRadius * 2 > barHeight ? barHeight / 2 : initialBorderRadius\n                        const showTopBorder = keyIndex === stack.length - 1\n                        const showBottomBorder = keyIndex === 0\n                        const commands = this.coordinatesToPathCommands(\n                            x0,\n                            y0,\n                            x1,\n                            y1,\n                            borderRadius,\n                            showTopBorder,\n                            showBottomBorder\n                        )\n\n                        return {\n                            path: this.commandsToSvgPath(commands),\n                            color: colors[stackIndex][keyIndex],\n                            key: keys[stackIndex][keyIndex],\n                        }\n                    })\n                })\n            })\n        }\n\n        return array.merge(areas)\n    }\n\n    coordinatesToPathCommands = (x0, y0, x1, y1, borderRadius, showTopBorder, showBottomBorder) => {\n        const commands = []\n        commands.push({ marker: 'M', values: [x0, y0] })\n\n        if (showTopBorder) {\n            const topLeft1 = [x0 + borderRadius, y0]\n            const topLeft2 = [x0, y0 + borderRadius]\n            commands.push({ marker: 'L', values: topLeft1 })\n            commands.push({\n                marker: 'C',\n                values: [...topLeft1, x0, y0, ...topLeft2],\n            })\n            commands.push({ marker: 'L', values: topLeft2 })\n        } else {\n            commands.push({ marker: 'L', values: [x0, y0] })\n        }\n\n        if (showBottomBorder) {\n            const bottomLeft1 = [x0, y1 - borderRadius]\n            const bottomLeft2 = [x0 + borderRadius, y1]\n            commands.push({ marker: 'L', values: bottomLeft1 })\n            commands.push({\n                marker: 'C',\n                values: [...bottomLeft1, x0, y1, ...bottomLeft2],\n            })\n            commands.push({ marker: 'L', values: bottomLeft2 })\n            const bottomRight1 = [x1 - borderRadius, y1]\n            const bottomRight2 = [x1, y1 - borderRadius]\n            commands.push({ marker: 'L', values: bottomRight1 })\n            commands.push({\n                marker: 'C',\n                values: [...bottomRight1, x1, y1, ...bottomRight2],\n            })\n            commands.push({ marker: 'L', values: bottomRight2 })\n        } else {\n            commands.push({ marker: 'L', values: [x0, y1] })\n            commands.push({ marker: 'L', values: [x1, y1] })\n        }\n\n        if (showTopBorder) {\n            const topRight1 = [x1, y0 + borderRadius]\n            const topRight2 = [x1 - borderRadius, y0]\n\n            commands.push({ marker: 'L', values: topRight1 })\n            commands.push({\n                marker: 'C',\n                values: [...topRight1, x1, y0, ...topRight2],\n            })\n            commands.push({ marker: 'L', values: topRight2 })\n        } else {\n            commands.push({ marker: 'L', values: [x1, y0] })\n        }\n\n        commands.push({ marker: 'Z', values: [] })\n\n        return commands\n    }\n\n    commandsToSvgPath = (commands) =>\n        commands\n            .map((command) => `${command.marker} ${command.values.join(',')}`)\n            .join(' ')\n            .trim()\n\n    calcExtent(values) {\n        const { gridMax, gridMin } = this.props\n\n        // One more merge for stacked groups\n        const mergedValues = array.merge(values)\n\n        return array.extent([...mergedValues, gridMin, gridMax])\n    }\n\n    calcIndexes() {\n        const { data } = this.props\n\n        // Must return an array with indexes for the number of groups to be shown\n        return data[0].data.map((_, index) => index)\n    }\n\n    getSeries() {\n        const { data, keys, offset, order, valueAccessor } = this.props\n\n        return data.map((obj, index) =>\n            shape\n                .stack()\n                .keys(keys[index])\n                .value((item, key) => valueAccessor({ item, key }))\n                .order(order)\n                .offset(offset)(obj.data)\n        )\n    }\n\n    render() {\n        const { data, animate, animationDuration, style, numberOfTicks, children, horizontal } = this.props\n\n        const { height, width } = this.state\n\n        if (data.length === 0) {\n            return <View style={style} />\n        }\n\n        const series = this.getSeries()\n\n        //double merge arrays to extract just the values\n        const values = array.merge(array.merge(series))\n        const indexes = this.calcIndexes(values)\n\n        const extent = this.calcExtent(values)\n        const ticks = array.ticks(extent[0], extent[1], numberOfTicks)\n\n        const xDomain = horizontal ? extent : indexes\n        const yDomain = horizontal ? indexes : extent\n\n        const x = this.calcXScale(xDomain)\n        const y = this.calcYScale(yDomain)\n\n        const bandwidth = horizontal ? y.bandwidth() : x.bandwidth()\n\n        const stacks = this.calcAreas(x, y, series)\n\n        const extraProps = {\n            x,\n            y,\n            width,\n            height,\n            ticks,\n            data,\n            bandwidth,\n        }\n\n        return (\n            <View style={style}>\n                <View style={{ flex: 1 }} onLayout={(event) => this._onLayout(event)}>\n                    {height > 0 && width > 0 && (\n                        <Svg style={{ height, width }}>\n                            {React.Children.map(children, (child) => {\n                                if (child && child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                            {stacks.map((areas, indexStack) => {\n                                const areaIndex = indexStack % data.length\n\n                                return areas.map((bar, indexArea) => {\n                                    const keyIndex = indexArea % data[areaIndex].data.length\n                                    const key = `${areaIndex}-${keyIndex}-${bar.key}`\n\n                                    const { svg } = data[areaIndex].data[keyIndex][bar.key]\n\n                                    return (\n                                        <Path\n                                            key={key}\n                                            fill={bar.color}\n                                            {...svg}\n                                            d={bar.path}\n                                            animate={animate}\n                                            animationDuration={animationDuration}\n                                        />\n                                    )\n                                })\n                            })}\n                            {React.Children.map(children, (child) => {\n                                if (child && !child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                        </Svg>\n                    )}\n                </View>\n            </View>\n        )\n    }\n}\n\nStackedBarGrouped.propTypes = {\n    data: PropTypes.arrayOf(PropTypes.object),\n    keys: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n    colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n    offset: PropTypes.func,\n    order: PropTypes.func,\n    style: PropTypes.any,\n    spacingInner: PropTypes.number,\n    spacingOuter: PropTypes.number,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    contentInset: PropTypes.shape({\n        top: PropTypes.number,\n        left: PropTypes.number,\n        right: PropTypes.number,\n        bottom: PropTypes.number,\n    }),\n    gridMin: PropTypes.number,\n    gridMax: PropTypes.number,\n    valueAccessor: PropTypes.func,\n    borderRadius: PropTypes.number,\n    innerBarSpace: PropTypes.number,\n}\n\nStackedBarGrouped.defaultProps = {\n    spacingInner: 0.05,\n    spacingOuter: 0.05,\n    offset: shape.stackOffsetNone,\n    order: shape.stackOrderNone,\n    width: 100,\n    height: 100,\n    showZeroAxis: true,\n    contentInset: {},\n    numberOfTicks: 10,\n    showGrid: true,\n    valueAccessor: ({ item, key }) => item[key],\n    borderRadius: 0,\n    innerBarSpace: 0,\n}\n\nexport default StackedBarGrouped\n"]},"metadata":{},"sourceType":"module"}