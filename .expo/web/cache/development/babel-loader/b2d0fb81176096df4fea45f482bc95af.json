{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport PropTypes from 'prop-types';\nimport * as array from 'd3-array';\nimport * as scale from 'd3-scale';\nimport * as shape from 'd3-shape';\nimport BarChart from \"./bar-chart\";\n\nclass GroupedBarChart extends BarChart {\n  calcXScale(domain) {\n    var {\n      horizontal,\n      contentInset: {\n        left = 0,\n        right = 0\n      },\n      spacingInner,\n      spacingOuter,\n      clamp\n    } = this.props;\n    var {\n      width\n    } = this.state;\n\n    if (horizontal) {\n      return scale.scaleLinear().domain(domain).range([left, width - right]).clamp(clamp);\n    }\n\n    return scale.scaleBand().domain(domain).range([left, width - right]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n  }\n\n  calcYScale(domain) {\n    var {\n      horizontal,\n      spacingInner,\n      spacingOuter,\n      contentInset: {\n        top = 0,\n        bottom = 0\n      },\n      clamp\n    } = this.props;\n    var {\n      height\n    } = this.state;\n\n    if (horizontal) {\n      return scale.scaleBand().domain(domain).range([top, height - bottom]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n    }\n\n    return scale.scaleLinear().domain(domain).range([height - bottom, top]).clamp(clamp);\n  }\n\n  calcAreas(x, y) {\n    var {\n      horizontal,\n      data,\n      yAccessor\n    } = this.props;\n\n    var _data = data.map(obj => {\n      var {\n        svg = {}\n      } = obj;\n      return _objectSpread({}, obj, {\n        data: obj.data.map(item => {\n          if (typeof item === 'number') {\n            return {\n              value: item,\n              svg\n            };\n          }\n\n          return _objectSpread({}, item, {\n            svg: _objectSpread({}, svg, {}, item.svg),\n            value: yAccessor({\n              item\n            })\n          });\n        })\n      });\n    });\n\n    var areas = [];\n\n    if (horizontal) {\n      var barWidth = y.bandwidth() / data.length;\n\n      _data.forEach((obj, collectionIndex) => {\n        obj.data.forEach((item, valueIndex) => {\n          areas.push({\n            bar: item,\n            path: shape.area().y((value, _index) => _index === 0 ? y(valueIndex) + barWidth * collectionIndex : y(valueIndex) + barWidth + barWidth * collectionIndex).x0(x(0)).x1(value => x(value)).defined(value => typeof value === 'number')([item.value, item.value])\n          });\n        });\n      });\n    } else {\n      var _barWidth = x.bandwidth() / data.length;\n\n      _data.forEach((obj, collectionIndex) => {\n        obj.data.forEach((item, valueIndex) => {\n          areas.push({\n            bar: item,\n            path: shape.area().x((value, _index) => _index === 0 ? x(valueIndex) + _barWidth * collectionIndex : x(valueIndex) + _barWidth + _barWidth * collectionIndex).y0(y(0)).y1(value => y(value)).defined(value => typeof value === 'number')([item.value, item.value])\n          });\n        });\n      });\n    }\n\n    return areas;\n  }\n\n  calcExtent() {\n    var {\n      data,\n      yAccessor,\n      gridMin,\n      gridMax\n    } = this.props;\n    var dataExtent = array.merge(data.map(obj => obj.data.map(item => yAccessor({\n      item\n    }))));\n    var extent = array.extent([...dataExtent, gridMax, gridMin]);\n    var {\n      yMin = extent[0],\n      yMax = extent[1]\n    } = this.props;\n    return [yMin, yMax];\n  }\n\n  calcIndexes() {\n    var {\n      data\n    } = this.props;\n    return data[0].data.map((_, index) => index);\n  }\n\n}\n\nGroupedBarChart.propTypes = _objectSpread({}, BarChart.propTypes, {\n  data: PropTypes.arrayOf(PropTypes.shape({\n    data: PropTypes.array.isRequired,\n    svg: PropTypes.object\n  })).isRequired\n});\nexport default GroupedBarChart;","map":{"version":3,"sources":["/Users/phakawat/Desktop/drowsy-mobile-app/node_modules/react-native-svg-charts/src/bar-chart/bar-chart-grouped.js"],"names":["PropTypes","array","scale","shape","BarChart","GroupedBarChart","calcXScale","domain","horizontal","contentInset","left","right","spacingInner","spacingOuter","clamp","props","width","state","scaleLinear","range","scaleBand","paddingInner","paddingOuter","calcYScale","top","bottom","height","calcAreas","x","y","data","yAccessor","_data","map","obj","svg","item","value","areas","barWidth","bandwidth","length","forEach","collectionIndex","valueIndex","push","bar","path","area","_index","x0","x1","defined","y0","y1","calcExtent","gridMin","gridMax","dataExtent","merge","extent","yMin","yMax","calcIndexes","_","index","propTypes","arrayOf","isRequired","object"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types'\nimport * as array from 'd3-array'\nimport * as scale from 'd3-scale'\nimport * as shape from 'd3-shape'\nimport BarChart from './bar-chart'\n\nclass GroupedBarChart extends BarChart {\n    calcXScale(domain) {\n        const {\n            horizontal,\n            contentInset: { left = 0, right = 0 },\n            spacingInner,\n            spacingOuter,\n            clamp,\n        } = this.props\n\n        const { width } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleLinear()\n                .domain(domain)\n                .range([left, width - right])\n                .clamp(clamp)\n        }\n\n        return scale\n            .scaleBand()\n            .domain(domain)\n            .range([left, width - right])\n            .paddingInner([spacingInner])\n            .paddingOuter([spacingOuter])\n    }\n\n    calcYScale(domain) {\n        const {\n            horizontal,\n            spacingInner,\n            spacingOuter,\n            contentInset: { top = 0, bottom = 0 },\n            clamp,\n        } = this.props\n\n        const { height } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleBand()\n                .domain(domain)\n                .range([top, height - bottom])\n                .paddingInner([spacingInner])\n                .paddingOuter([spacingOuter])\n        }\n\n        return scale\n            .scaleLinear()\n            .domain(domain)\n            .range([height - bottom, top])\n            .clamp(clamp)\n    }\n\n    calcAreas(x, y) {\n        const { horizontal, data, yAccessor } = this.props\n\n        const _data = data.map((obj) => {\n            const { svg = {} } = obj\n            return {\n                ...obj,\n                data: obj.data.map((item) => {\n                    if (typeof item === 'number') {\n                        return {\n                            value: item,\n                            svg,\n                        }\n                    }\n\n                    return {\n                        ...item,\n                        svg: {\n                            ...svg,\n                            ...item.svg,\n                        },\n                        value: yAccessor({ item }),\n                    }\n                }),\n            }\n        })\n\n        const areas = []\n\n        if (horizontal) {\n            const barWidth = y.bandwidth() / data.length\n\n            _data.forEach((obj, collectionIndex) => {\n                obj.data.forEach((item, valueIndex) => {\n                    areas.push({\n                        bar: item,\n                        path: shape\n                            .area()\n                            .y((value, _index) =>\n                                _index === 0\n                                    ? y(valueIndex) + barWidth * collectionIndex\n                                    : y(valueIndex) + barWidth + barWidth * collectionIndex\n                            )\n                            .x0(x(0))\n                            .x1((value) => x(value))\n                            .defined((value) => typeof value === 'number')([item.value, item.value]),\n                    })\n                })\n            })\n        } else {\n            const barWidth = x.bandwidth() / data.length\n\n            _data.forEach((obj, collectionIndex) => {\n                obj.data.forEach((item, valueIndex) => {\n                    areas.push({\n                        bar: item,\n                        path: shape\n                            .area()\n                            .x((value, _index) =>\n                                _index === 0\n                                    ? x(valueIndex) + barWidth * collectionIndex\n                                    : x(valueIndex) + barWidth + barWidth * collectionIndex\n                            )\n                            .y0(y(0))\n                            .y1((value) => y(value))\n                            .defined((value) => typeof value === 'number')([item.value, item.value]),\n                    })\n                })\n            })\n        }\n\n        return areas\n    }\n\n    calcExtent() {\n        const { data, yAccessor, gridMin, gridMax } = this.props\n        const dataExtent = array.merge(data.map((obj) => obj.data.map((item) => yAccessor({ item }))))\n\n        const extent = array.extent([...dataExtent, gridMax, gridMin])\n\n        const { yMin = extent[0], yMax = extent[1] } = this.props\n\n        return [yMin, yMax]\n    }\n\n    calcIndexes() {\n        const { data } = this.props\n        return data[0].data.map((_, index) => index)\n    }\n}\n\nGroupedBarChart.propTypes = {\n    ...BarChart.propTypes,\n    data: PropTypes.arrayOf(\n        PropTypes.shape({\n            data: PropTypes.array.isRequired,\n            svg: PropTypes.object,\n        })\n    ).isRequired,\n}\n\nexport default GroupedBarChart\n"]},"metadata":{},"sourceType":"module"}